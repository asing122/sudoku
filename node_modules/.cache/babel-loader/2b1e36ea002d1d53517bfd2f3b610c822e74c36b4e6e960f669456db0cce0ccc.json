{"ast":null,"code":"// JS program to implement the approach\nexport class Sudoku {\n  // Constructor\n  constructor(N, K) {\n    this.N = void 0;\n    this.SRN = void 0;\n    this.mat = void 0;\n    this.N = 9;\n    // this.K = 40;\n\n    // Compute square root of N\n    this.SRN = 3;\n\n    // Initialize all entries as false to indicate\n    // that there are no edges initially\n    let sampleBoardItem = {\n      row: 0,\n      col: 0,\n      box: 0,\n      num: 0\n    };\n    this.mat = Array.from({\n      length: N * N\n    }, () => sampleBoardItem);\n  }\n\n  // Sudoku Generator\n  fillValues() {\n    // Fill the diagonal of SRN x SRN matrices\n    this.DiagonalBoxes();\n\n    // Fill remaining blocks\n    // this.fillRemaining(0, this.SRN);\n  }\n\n  // Fill the diagonal SRN number of SRN x SRN matrices\n  // fillDiagonal() {\n  //   for (let i = 0; i < this.N; i += this.SRN) {\n  //     // for diagonal box, start coordinates->i==j\n  //     this.fillBox(i, i, i);\n  //   }\n  // }\n\n  DiagonalBoxes() {\n    for (let i = 0; i < 9; i += 4) {\n      let numbers = shuffleArray(Array.from(Array(9).keys()).map(num => num + 1));\n      for (let itemNumber = 0; itemNumber < 9; itemNumber++) {\n        let sudokuItem = numbers.pop() || 8;\n        let rowNumber = Math.floor(itemNumber / 3);\n        let colNumber = itemNumber % 3;\n        let boxNumber = i;\n        board.push({\n          box: boxNumber,\n          row: rowNumber,\n          num: sudokuItem,\n          col: colNumber\n        });\n      }\n    }\n    return board;\n  }\n\n  // Returns false if given 3 x 3 block contains num.\n  unUsedInBox(rowStart, colStart, num) {\n    for (let i = 0; i < this.SRN; i++) {\n      for (let j = 0; j < this.SRN; j++) {\n        if (this.mat[(rowStart + i) * 9 + colStart + j].num === num) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  // Fill a 3 x 3 matrix.\n  fillBox(row, col, box) {\n    let num = 0;\n    for (let i = 0; i < 3; i++) {\n      for (let j = 0; j < 3; j++) {\n        while (true) {\n          num = this.randomGenerator(this.N);\n          if (this.unUsedInBox(row, col, num)) {\n            break;\n          }\n        }\n        this.mat[(row + i) * 9 + (col + j)] = {\n          row: row + i,\n          col: col + j,\n          box: box,\n          num: num\n        };\n      }\n    }\n  }\n\n  // Random generator\n  randomGenerator(num) {\n    return Math.floor(Math.random() * num + 1);\n  }\n\n  // Check if safe to put in cell\n  checkIfSafe(i, j, num) {\n    return this.unUsedInRow(i, num) && this.unUsedInCol(j, num) && this.unUsedInBox(i - i % this.SRN, j - j % this.SRN, num);\n  }\n\n  // check in the row for existence\n  unUsedInRow(i, num) {\n    for (let j = 0; j < this.N; j++) {\n      if (this.mat[i * 9 + j].num === num) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // check in the row for existence\n  unUsedInCol(j, num) {\n    for (let i = 0; i < this.N; i++) {\n      if (this.mat[i * 9 + j].num === num) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // A recursive function to fill remaining\n  // matrix\n  fillRemaining(i, j) {\n    // Check if we have reached the end of the matrix\n    if (i === this.N - 1 && j === this.N) {\n      return true;\n    }\n\n    // Move to the next row if we have reached the end of the current row\n    if (j === this.N) {\n      i += 1;\n      j = 0;\n    }\n\n    // Skip cells that are already filled\n    if (this.mat[i * 9 + j].num !== 0) {\n      return this.fillRemaining(i, j + 1);\n    }\n\n    // Try filling the current cell with a valid value\n    for (let num = 1; num <= this.N; num++) {\n      if (this.checkIfSafe(i, j, num)) {\n        this.mat[i * 9 + j] = {\n          row: i,\n          col: j,\n          box: i - i % 3 + j - j % 3,\n          num: num\n        };\n        if (this.fillRemaining(i, j + 1)) {\n          return true;\n        }\n        this.mat[i * 9 + j] = {\n          row: 0,\n          col: 0,\n          box: 0,\n          num: 0\n        };\n      }\n    }\n\n    // No valid value was found, so backtrack\n    return false;\n  }\n\n  // Print sudoku\n  // printSudoku() {\n  //   for (let i = 0; i < this.N; i++) {\n  //     console.log(this.mat[i].join(\" \"));\n  //   }\n  // }\n\n  // // Remove the K no. of digits to\n  // // complete game\n  // removeKDigits() {\n  //     let count = this.K;\n\n  //     while (count !== 0) {\n  //         // extract coordinates i and j\n  //         let i = Math.floor(Math.random() * this.N);\n  //         let j = Math.floor(Math.random() * this.N);\n  //         if (this.mat[i][j] !== 0) {\n  //             count--;\n  //             this.mat[i][j] = 0;\n  //         }\n  //     }\n\n  //     return;\n  // }\n}\n\n// // Driver code\n// let N = 9\n// let K = 40\n// let sudoku = new Sudoku(N, K)\n// sudoku.fillValues()\n// sudoku.printSudoku()\n\n// This code is contributed by phasing17.\n\nfunction shuffleArray(array) {\n  for (var i = array.length - 1; i > 0; i--) {\n    var j = Math.floor(Math.random() * (i + 1));\n    var temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n  }\n  return array;\n}","map":{"version":3,"names":["Sudoku","constructor","N","K","SRN","mat","sampleBoardItem","row","col","box","num","Array","from","length","fillValues","DiagonalBoxes","i","numbers","shuffleArray","keys","map","itemNumber","sudokuItem","pop","rowNumber","Math","floor","colNumber","boxNumber","board","push","unUsedInBox","rowStart","colStart","j","fillBox","randomGenerator","random","checkIfSafe","unUsedInRow","unUsedInCol","fillRemaining","array","temp"],"sources":["/Users/annikasingh/Desktop/hi/sudoku/src/components/Sudoku.tsx"],"sourcesContent":["import { Board } from \"./TestCode\";\n\nexport type NewBoard = {\n  box: number;\n  num: number;\n};\n\n// JS program to implement the approach\nexport class Sudoku {\n  N: number;\n  SRN: number;\n  mat: Board[];\n  // Constructor\n  constructor(N: number, K: number) {\n    this.N = 9;\n    // this.K = 40;\n\n    // Compute square root of N\n    this.SRN = 3;\n\n    // Initialize all entries as false to indicate\n    // that there are no edges initially\n    let sampleBoardItem: Board = {\n      row: 0,\n      col: 0,\n      box: 0,\n      num: 0,\n    };\n    this.mat = Array.from(\n      {\n        length: N * N,\n      },\n      () => sampleBoardItem\n    );\n  }\n\n  // Sudoku Generator\n  fillValues() {\n    // Fill the diagonal of SRN x SRN matrices\n    this.DiagonalBoxes();\n\n    // Fill remaining blocks\n    // this.fillRemaining(0, this.SRN);\n  }\n\n  // Fill the diagonal SRN number of SRN x SRN matrices\n  // fillDiagonal() {\n  //   for (let i = 0; i < this.N; i += this.SRN) {\n  //     // for diagonal box, start coordinates->i==j\n  //     this.fillBox(i, i, i);\n  //   }\n  // }\n\n  DiagonalBoxes() {\n    for (let i = 0; i < 9; i += 4) {\n      let numbers = shuffleArray(\n        Array.from(Array(9).keys()).map((num) => num + 1)\n      );\n      for (let itemNumber = 0; itemNumber < 9; itemNumber++) {\n        let sudokuItem = numbers.pop() || 8;\n        let rowNumber = Math.floor(itemNumber / 3);\n        let colNumber = itemNumber % 3;\n        let boxNumber = i;\n        board.push({\n          box: boxNumber,\n          row: rowNumber,\n          num: sudokuItem,\n          col: colNumber,\n        });\n      }\n    }\n    return board;\n  }\n\n  // Returns false if given 3 x 3 block contains num.\n  unUsedInBox(rowStart: number, colStart: number, num: number) {\n    for (let i = 0; i < this.SRN; i++) {\n      for (let j = 0; j < this.SRN; j++) {\n        if (this.mat[(rowStart + i) * 9 + colStart + j].num === num) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  // Fill a 3 x 3 matrix.\n  fillBox(row: number, col: number, box: number) {\n    let num = 0;\n    for (let i = 0; i < 3; i++) {\n      for (let j = 0; j < 3; j++) {\n        while (true) {\n          num = this.randomGenerator(this.N);\n          if (this.unUsedInBox(row, col, num)) {\n            break;\n          }\n        }\n        this.mat[(row + i) * 9 + (col + j)] = {\n          row: row + i,\n          col: col + j,\n          box: box,\n          num: num,\n        };\n      }\n    }\n  }\n\n  // Random generator\n  randomGenerator(num: number) {\n    return Math.floor(Math.random() * num + 1);\n  }\n\n  // Check if safe to put in cell\n  checkIfSafe(i: number, j: number, num: number) {\n    return (\n      this.unUsedInRow(i, num) &&\n      this.unUsedInCol(j, num) &&\n      this.unUsedInBox(i - (i % this.SRN), j - (j % this.SRN), num)\n    );\n  }\n\n  // check in the row for existence\n  unUsedInRow(i: number, num: number) {\n    for (let j = 0; j < this.N; j++) {\n      if (this.mat[i * 9 + j].num === num) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // check in the row for existence\n  unUsedInCol(j: number, num: number) {\n    for (let i = 0; i < this.N; i++) {\n      if (this.mat[i * 9 + j].num === num) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // A recursive function to fill remaining\n  // matrix\n  fillRemaining(i: number, j: number): boolean {\n    // Check if we have reached the end of the matrix\n    if (i === this.N - 1 && j === this.N) {\n      return true;\n    }\n\n    // Move to the next row if we have reached the end of the current row\n    if (j === this.N) {\n      i += 1;\n      j = 0;\n    }\n\n    // Skip cells that are already filled\n    if (this.mat[i * 9 + j].num !== 0) {\n      return this.fillRemaining(i, j + 1);\n    }\n\n    // Try filling the current cell with a valid value\n    for (let num = 1; num <= this.N; num++) {\n      if (this.checkIfSafe(i, j, num)) {\n        this.mat[i * 9 + j] = {\n          row: i,\n          col: j,\n          box: i - (i % 3) + j - (j % 3),\n          num: num,\n        };\n        if (this.fillRemaining(i, j + 1)) {\n          return true;\n        }\n        this.mat[i * 9 + j] = {\n          row: 0,\n          col: 0,\n          box: 0,\n          num: 0,\n        };\n      }\n    }\n\n    // No valid value was found, so backtrack\n    return false;\n  }\n\n  // Print sudoku\n  // printSudoku() {\n  //   for (let i = 0; i < this.N; i++) {\n  //     console.log(this.mat[i].join(\" \"));\n  //   }\n  // }\n\n  // // Remove the K no. of digits to\n  // // complete game\n  // removeKDigits() {\n  //     let count = this.K;\n\n  //     while (count !== 0) {\n  //         // extract coordinates i and j\n  //         let i = Math.floor(Math.random() * this.N);\n  //         let j = Math.floor(Math.random() * this.N);\n  //         if (this.mat[i][j] !== 0) {\n  //             count--;\n  //             this.mat[i][j] = 0;\n  //         }\n  //     }\n\n  //     return;\n  // }\n}\n\n// // Driver code\n// let N = 9\n// let K = 40\n// let sudoku = new Sudoku(N, K)\n// sudoku.fillValues()\n// sudoku.printSudoku()\n\n// This code is contributed by phasing17.\n\nfunction shuffleArray(array: any[]): any[] {\n  for (var i = array.length - 1; i > 0; i--) {\n    var j = Math.floor(Math.random() * (i + 1));\n\n    var temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n  }\n\n  return array;\n}\n"],"mappings":"AAOA;AACA,OAAO,MAAMA,MAAM,CAAC;EAIlB;EACAC,WAAWA,CAACC,CAAS,EAAEC,CAAS,EAAE;IAAA,KAJlCD,CAAC;IAAA,KACDE,GAAG;IAAA,KACHC,GAAG;IAGD,IAAI,CAACH,CAAC,GAAG,CAAC;IACV;;IAEA;IACA,IAAI,CAACE,GAAG,GAAG,CAAC;;IAEZ;IACA;IACA,IAAIE,eAAsB,GAAG;MAC3BC,GAAG,EAAE,CAAC;MACNC,GAAG,EAAE,CAAC;MACNC,GAAG,EAAE,CAAC;MACNC,GAAG,EAAE;IACP,CAAC;IACD,IAAI,CAACL,GAAG,GAAGM,KAAK,CAACC,IAAI,CACnB;MACEC,MAAM,EAAEX,CAAC,GAAGA;IACd,CAAC,EACD,MAAMI,eACR,CAAC;EACH;;EAEA;EACAQ,UAAUA,CAAA,EAAG;IACX;IACA,IAAI,CAACC,aAAa,CAAC,CAAC;;IAEpB;IACA;EACF;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEAA,aAAaA,CAAA,EAAG;IACd,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAE;MAC7B,IAAIC,OAAO,GAAGC,YAAY,CACxBP,KAAK,CAACC,IAAI,CAACD,KAAK,CAAC,CAAC,CAAC,CAACQ,IAAI,CAAC,CAAC,CAAC,CAACC,GAAG,CAAEV,GAAG,IAAKA,GAAG,GAAG,CAAC,CAClD,CAAC;MACD,KAAK,IAAIW,UAAU,GAAG,CAAC,EAAEA,UAAU,GAAG,CAAC,EAAEA,UAAU,EAAE,EAAE;QACrD,IAAIC,UAAU,GAAGL,OAAO,CAACM,GAAG,CAAC,CAAC,IAAI,CAAC;QACnC,IAAIC,SAAS,GAAGC,IAAI,CAACC,KAAK,CAACL,UAAU,GAAG,CAAC,CAAC;QAC1C,IAAIM,SAAS,GAAGN,UAAU,GAAG,CAAC;QAC9B,IAAIO,SAAS,GAAGZ,CAAC;QACjBa,KAAK,CAACC,IAAI,CAAC;UACTrB,GAAG,EAAEmB,SAAS;UACdrB,GAAG,EAAEiB,SAAS;UACdd,GAAG,EAAEY,UAAU;UACfd,GAAG,EAAEmB;QACP,CAAC,CAAC;MACJ;IACF;IACA,OAAOE,KAAK;EACd;;EAEA;EACAE,WAAWA,CAACC,QAAgB,EAAEC,QAAgB,EAAEvB,GAAW,EAAE;IAC3D,KAAK,IAAIM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACZ,GAAG,EAAEY,CAAC,EAAE,EAAE;MACjC,KAAK,IAAIkB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAC9B,GAAG,EAAE8B,CAAC,EAAE,EAAE;QACjC,IAAI,IAAI,CAAC7B,GAAG,CAAC,CAAC2B,QAAQ,GAAGhB,CAAC,IAAI,CAAC,GAAGiB,QAAQ,GAAGC,CAAC,CAAC,CAACxB,GAAG,KAAKA,GAAG,EAAE;UAC3D,OAAO,KAAK;QACd;MACF;IACF;IACA,OAAO,IAAI;EACb;;EAEA;EACAyB,OAAOA,CAAC5B,GAAW,EAAEC,GAAW,EAAEC,GAAW,EAAE;IAC7C,IAAIC,GAAG,GAAG,CAAC;IACX,KAAK,IAAIM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;MAC1B,KAAK,IAAIkB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;QAC1B,OAAO,IAAI,EAAE;UACXxB,GAAG,GAAG,IAAI,CAAC0B,eAAe,CAAC,IAAI,CAAClC,CAAC,CAAC;UAClC,IAAI,IAAI,CAAC6B,WAAW,CAACxB,GAAG,EAAEC,GAAG,EAAEE,GAAG,CAAC,EAAE;YACnC;UACF;QACF;QACA,IAAI,CAACL,GAAG,CAAC,CAACE,GAAG,GAAGS,CAAC,IAAI,CAAC,IAAIR,GAAG,GAAG0B,CAAC,CAAC,CAAC,GAAG;UACpC3B,GAAG,EAAEA,GAAG,GAAGS,CAAC;UACZR,GAAG,EAAEA,GAAG,GAAG0B,CAAC;UACZzB,GAAG,EAAEA,GAAG;UACRC,GAAG,EAAEA;QACP,CAAC;MACH;IACF;EACF;;EAEA;EACA0B,eAAeA,CAAC1B,GAAW,EAAE;IAC3B,OAAOe,IAAI,CAACC,KAAK,CAACD,IAAI,CAACY,MAAM,CAAC,CAAC,GAAG3B,GAAG,GAAG,CAAC,CAAC;EAC5C;;EAEA;EACA4B,WAAWA,CAACtB,CAAS,EAAEkB,CAAS,EAAExB,GAAW,EAAE;IAC7C,OACE,IAAI,CAAC6B,WAAW,CAACvB,CAAC,EAAEN,GAAG,CAAC,IACxB,IAAI,CAAC8B,WAAW,CAACN,CAAC,EAAExB,GAAG,CAAC,IACxB,IAAI,CAACqB,WAAW,CAACf,CAAC,GAAIA,CAAC,GAAG,IAAI,CAACZ,GAAI,EAAE8B,CAAC,GAAIA,CAAC,GAAG,IAAI,CAAC9B,GAAI,EAAEM,GAAG,CAAC;EAEjE;;EAEA;EACA6B,WAAWA,CAACvB,CAAS,EAAEN,GAAW,EAAE;IAClC,KAAK,IAAIwB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAChC,CAAC,EAAEgC,CAAC,EAAE,EAAE;MAC/B,IAAI,IAAI,CAAC7B,GAAG,CAACW,CAAC,GAAG,CAAC,GAAGkB,CAAC,CAAC,CAACxB,GAAG,KAAKA,GAAG,EAAE;QACnC,OAAO,KAAK;MACd;IACF;IACA,OAAO,IAAI;EACb;;EAEA;EACA8B,WAAWA,CAACN,CAAS,EAAExB,GAAW,EAAE;IAClC,KAAK,IAAIM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACd,CAAC,EAAEc,CAAC,EAAE,EAAE;MAC/B,IAAI,IAAI,CAACX,GAAG,CAACW,CAAC,GAAG,CAAC,GAAGkB,CAAC,CAAC,CAACxB,GAAG,KAAKA,GAAG,EAAE;QACnC,OAAO,KAAK;MACd;IACF;IACA,OAAO,IAAI;EACb;;EAEA;EACA;EACA+B,aAAaA,CAACzB,CAAS,EAAEkB,CAAS,EAAW;IAC3C;IACA,IAAIlB,CAAC,KAAK,IAAI,CAACd,CAAC,GAAG,CAAC,IAAIgC,CAAC,KAAK,IAAI,CAAChC,CAAC,EAAE;MACpC,OAAO,IAAI;IACb;;IAEA;IACA,IAAIgC,CAAC,KAAK,IAAI,CAAChC,CAAC,EAAE;MAChBc,CAAC,IAAI,CAAC;MACNkB,CAAC,GAAG,CAAC;IACP;;IAEA;IACA,IAAI,IAAI,CAAC7B,GAAG,CAACW,CAAC,GAAG,CAAC,GAAGkB,CAAC,CAAC,CAACxB,GAAG,KAAK,CAAC,EAAE;MACjC,OAAO,IAAI,CAAC+B,aAAa,CAACzB,CAAC,EAAEkB,CAAC,GAAG,CAAC,CAAC;IACrC;;IAEA;IACA,KAAK,IAAIxB,GAAG,GAAG,CAAC,EAAEA,GAAG,IAAI,IAAI,CAACR,CAAC,EAAEQ,GAAG,EAAE,EAAE;MACtC,IAAI,IAAI,CAAC4B,WAAW,CAACtB,CAAC,EAAEkB,CAAC,EAAExB,GAAG,CAAC,EAAE;QAC/B,IAAI,CAACL,GAAG,CAACW,CAAC,GAAG,CAAC,GAAGkB,CAAC,CAAC,GAAG;UACpB3B,GAAG,EAAES,CAAC;UACNR,GAAG,EAAE0B,CAAC;UACNzB,GAAG,EAAEO,CAAC,GAAIA,CAAC,GAAG,CAAE,GAAGkB,CAAC,GAAIA,CAAC,GAAG,CAAE;UAC9BxB,GAAG,EAAEA;QACP,CAAC;QACD,IAAI,IAAI,CAAC+B,aAAa,CAACzB,CAAC,EAAEkB,CAAC,GAAG,CAAC,CAAC,EAAE;UAChC,OAAO,IAAI;QACb;QACA,IAAI,CAAC7B,GAAG,CAACW,CAAC,GAAG,CAAC,GAAGkB,CAAC,CAAC,GAAG;UACpB3B,GAAG,EAAE,CAAC;UACNC,GAAG,EAAE,CAAC;UACNC,GAAG,EAAE,CAAC;UACNC,GAAG,EAAE;QACP,CAAC;MACH;IACF;;IAEA;IACA,OAAO,KAAK;EACd;;EAEA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,SAASQ,YAAYA,CAACwB,KAAY,EAAS;EACzC,KAAK,IAAI1B,CAAC,GAAG0B,KAAK,CAAC7B,MAAM,GAAG,CAAC,EAAEG,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;IACzC,IAAIkB,CAAC,GAAGT,IAAI,CAACC,KAAK,CAACD,IAAI,CAACY,MAAM,CAAC,CAAC,IAAIrB,CAAC,GAAG,CAAC,CAAC,CAAC;IAE3C,IAAI2B,IAAI,GAAGD,KAAK,CAAC1B,CAAC,CAAC;IACnB0B,KAAK,CAAC1B,CAAC,CAAC,GAAG0B,KAAK,CAACR,CAAC,CAAC;IACnBQ,KAAK,CAACR,CAAC,CAAC,GAAGS,IAAI;EACjB;EAEA,OAAOD,KAAK;AACd","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}