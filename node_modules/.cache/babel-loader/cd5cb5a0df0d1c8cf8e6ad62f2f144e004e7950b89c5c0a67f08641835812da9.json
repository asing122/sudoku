{"ast":null,"code":"// JS program to implement the approach\nclass Sudoku {\n  // Constructor\n  constructor(N, K) {\n    this.N = 9;\n    // this.K = 40;\n\n    // Compute square root of N\n    this.SRN = 3;\n\n    // Initialize all entries as false to indicate\n    // that there are no edges initially\n    this.mat = Array.from({\n      length: N\n    }, () => Array.from({\n      length: N\n    }, () => 0));\n  }\n\n  // Sudoku Generator\n  fillValues() {\n    // Fill the diagonal of SRN x SRN matrices\n    this.fillDiagonal();\n\n    // Fill remaining blocks\n    this.fillRemaining(0, this.SRN);\n\n    // Remove Randomly K digits to make game\n    this.removeKDigits();\n  }\n\n  // Fill the diagonal SRN number of SRN x SRN matrices\n  fillDiagonal() {\n    for (let i = 0; i < this.N; i += this.SRN) {\n      // for diagonal box, start coordinates->i==j\n      this.fillBox(i, i);\n    }\n  }\n\n  // Returns false if given 3 x 3 block contains num.\n  unUsedInBox(rowStart, colStart, num) {\n    for (let i = 0; i < this.SRN; i++) {\n      for (let j = 0; j < this.SRN; j++) {\n        if (this.mat[rowStart + i][colStart + j] === num) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  // Fill a 3 x 3 matrix.\n  fillBox(row, col) {\n    let num = 0;\n    for (let i = 0; i < this.SRN; i++) {\n      for (let j = 0; j < this.SRN; j++) {\n        while (true) {\n          num = this.randomGenerator(this.N);\n          if (this.unUsedInBox(row, col, num)) {\n            break;\n          }\n        }\n        this.mat[row + i][col + j] = num;\n      }\n    }\n  }\n\n  // Random generator\n  randomGenerator(num) {\n    return Math.floor(Math.random() * num + 1);\n  }\n\n  // Check if safe to put in cell\n  checkIfSafe(i, j, num) {\n    return this.unUsedInRow(i, num) && this.unUsedInCol(j, num) && this.unUsedInBox(i - i % this.SRN, j - j % this.SRN, num);\n  }\n\n  // check in the row for existence\n  unUsedInRow(i, num) {\n    for (let j = 0; j < this.N; j++) {\n      if (this.mat[i][j] === num) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // check in the row for existence\n  unUsedInCol(j, num) {\n    for (let i = 0; i < this.N; i++) {\n      if (this.mat[i][j] === num) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // A recursive function to fill remaining\n  // matrix\n  fillRemaining(i, j) {\n    // Check if we have reached the end of the matrix\n    if (i === this.N - 1 && j === this.N) {\n      return true;\n    }\n\n    // Move to the next row if we have reached the end of the current row\n    if (j === this.N) {\n      i += 1;\n      j = 0;\n    }\n\n    // Skip cells that are already filled\n    if (this.mat[i][j] !== 0) {\n      return this.fillRemaining(i, j + 1);\n    }\n\n    // Try filling the current cell with a valid value\n    for (let num = 1; num <= this.N; num++) {\n      if (this.checkIfSafe(i, j, num)) {\n        this.mat[i][j] = num;\n        if (this.fillRemaining(i, j + 1)) {\n          return true;\n        }\n        this.mat[i][j] = 0;\n      }\n    }\n\n    // No valid value was found, so backtrack\n    return false;\n  }\n\n  // Print sudoku\n  printSudoku() {\n    for (let i = 0; i < this.N; i++) {\n      console.log(this.mat[i].join(\" \"));\n    }\n  }\n\n  // // Remove the K no. of digits to\n  // // complete game\n  // removeKDigits() {\n  //     let count = this.K;\n\n  //     while (count !== 0) {\n  //         // extract coordinates i and j\n  //         let i = Math.floor(Math.random() * this.N);\n  //         let j = Math.floor(Math.random() * this.N);\n  //         if (this.mat[i][j] !== 0) {\n  //             count--;\n  //             this.mat[i][j] = 0;\n  //         }\n  //     }\n\n  //     return;\n  // }\n}\n\n// // Driver code\n// let N = 9\n// let K = 40\n// let sudoku = new Sudoku(N, K)\n// sudoku.fillValues()\n// sudoku.printSudoku()\n\n// This code is contributed by phasing17.","map":{"version":3,"names":["Sudoku","constructor","N","K","SRN","mat","Array","from","length","fillValues","fillDiagonal","fillRemaining","removeKDigits","i","fillBox","unUsedInBox","rowStart","colStart","num","j","row","col","randomGenerator","Math","floor","random","checkIfSafe","unUsedInRow","unUsedInCol","printSudoku","console","log","join"],"sources":["/Users/annikasingh/Desktop/hi/sudoku/src/components/Sudoku.js"],"sourcesContent":["// JS program to implement the approach\nclass Sudoku {\n  // Constructor\n  constructor(N, K) {\n    this.N = 9;\n    // this.K = 40;\n\n    // Compute square root of N\n    this.SRN = 3;\n\n    // Initialize all entries as false to indicate\n    // that there are no edges initially\n    this.mat = Array.from(\n      {\n        length: N,\n      },\n      () =>\n        Array.from(\n          {\n            length: N,\n          },\n          () => 0\n        )\n    );\n  }\n\n  // Sudoku Generator\n  fillValues() {\n    // Fill the diagonal of SRN x SRN matrices\n    this.fillDiagonal();\n\n    // Fill remaining blocks\n    this.fillRemaining(0, this.SRN);\n\n    // Remove Randomly K digits to make game\n    this.removeKDigits();\n  }\n\n  // Fill the diagonal SRN number of SRN x SRN matrices\n  fillDiagonal() {\n    for (let i = 0; i < this.N; i += this.SRN) {\n      // for diagonal box, start coordinates->i==j\n      this.fillBox(i, i);\n    }\n  }\n\n  // Returns false if given 3 x 3 block contains num.\n  unUsedInBox(rowStart, colStart, num) {\n    for (let i = 0; i < this.SRN; i++) {\n      for (let j = 0; j < this.SRN; j++) {\n        if (this.mat[rowStart + i][colStart + j] === num) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  // Fill a 3 x 3 matrix.\n  fillBox(row, col) {\n    let num = 0;\n    for (let i = 0; i < this.SRN; i++) {\n      for (let j = 0; j < this.SRN; j++) {\n        while (true) {\n          num = this.randomGenerator(this.N);\n          if (this.unUsedInBox(row, col, num)) {\n            break;\n          }\n        }\n        this.mat[row + i][col + j] = num;\n      }\n    }\n  }\n\n  // Random generator\n  randomGenerator(num) {\n    return Math.floor(Math.random() * num + 1);\n  }\n\n  // Check if safe to put in cell\n  checkIfSafe(i, j, num) {\n    return (\n      this.unUsedInRow(i, num) &&\n      this.unUsedInCol(j, num) &&\n      this.unUsedInBox(i - (i % this.SRN), j - (j % this.SRN), num)\n    );\n  }\n\n  // check in the row for existence\n  unUsedInRow(i, num) {\n    for (let j = 0; j < this.N; j++) {\n      if (this.mat[i][j] === num) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // check in the row for existence\n  unUsedInCol(j, num) {\n    for (let i = 0; i < this.N; i++) {\n      if (this.mat[i][j] === num) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // A recursive function to fill remaining\n  // matrix\n  fillRemaining(i, j) {\n    // Check if we have reached the end of the matrix\n    if (i === this.N - 1 && j === this.N) {\n      return true;\n    }\n\n    // Move to the next row if we have reached the end of the current row\n    if (j === this.N) {\n      i += 1;\n      j = 0;\n    }\n\n    // Skip cells that are already filled\n    if (this.mat[i][j] !== 0) {\n      return this.fillRemaining(i, j + 1);\n    }\n\n    // Try filling the current cell with a valid value\n    for (let num = 1; num <= this.N; num++) {\n      if (this.checkIfSafe(i, j, num)) {\n        this.mat[i][j] = num;\n        if (this.fillRemaining(i, j + 1)) {\n          return true;\n        }\n        this.mat[i][j] = 0;\n      }\n    }\n\n    // No valid value was found, so backtrack\n    return false;\n  }\n\n  // Print sudoku\n  printSudoku() {\n    for (let i = 0; i < this.N; i++) {\n      console.log(this.mat[i].join(\" \"));\n    }\n  }\n\n  // // Remove the K no. of digits to\n  // // complete game\n  // removeKDigits() {\n  //     let count = this.K;\n\n  //     while (count !== 0) {\n  //         // extract coordinates i and j\n  //         let i = Math.floor(Math.random() * this.N);\n  //         let j = Math.floor(Math.random() * this.N);\n  //         if (this.mat[i][j] !== 0) {\n  //             count--;\n  //             this.mat[i][j] = 0;\n  //         }\n  //     }\n\n  //     return;\n  // }\n}\n\n// // Driver code\n// let N = 9\n// let K = 40\n// let sudoku = new Sudoku(N, K)\n// sudoku.fillValues()\n// sudoku.printSudoku()\n\n// This code is contributed by phasing17.\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}