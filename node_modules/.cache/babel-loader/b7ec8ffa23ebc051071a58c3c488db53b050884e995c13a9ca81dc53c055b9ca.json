{"ast":null,"code":"// JS program to implement the approach\nexport class Sudoku {\n  // Constructor\n  constructor(N, K) {\n    this.N = N;\n    this.K = K;\n\n    // Compute square root of N\n    const SRNd = Math.sqrt(N);\n    this.SRN = Math.floor(SRNd);\n\n    // Initialize all entries as false to indicate\n    // that there are no edges initially\n    this.mat = Array.from({\n      length: N * N\n    });\n  }\n\n  // Sudoku Generator\n  fillValues() {\n    // Fill the diagonal of SRN x SRN matrices\n    this.DiagonalBoxes();\n\n    // Fill remaining blocks\n    this.fillRemaining(0, this.SRN);\n\n    // Remove Randomly K digits to make game\n    //this.removeKDigits();\n  }\n\n  // Fill the diagonal SRN number of SRN x SRN matrices\n  // fillDiagonal() {\n  //   for (let i = 0; i < this.N; i += this.SRN) {\n  //     // for diagonal box, start coordinates->i==j\n  //     this.fillBox(i, i);\n  //   }\n  // }\n\n  DiagonalBoxes() {\n    for (let i = 0; i < 9; i += 4) {\n      let numbers = shuffleArray(Array.from(Array(9).keys()).map(num => num + 1));\n      for (let itemNumber = 0; itemNumber < 9; itemNumber++) {\n        let sudokuItem = numbers.pop() || 8;\n        let rowNumber = Math.floor(itemNumber / 3);\n        let colNumber = itemNumber % 3;\n        let boxNumber = i;\n        board.push({\n          box: boxNumber,\n          row: rowNumber,\n          num: sudokuItem,\n          col: colNumber\n        });\n      }\n    }\n  }\n\n  // Returns false if given 3 x 3 block contains num.\n  unUsedInBox(rowStart, colStart, num) {\n    for (let i = 0; i < this.SRN; i++) {\n      for (let j = 0; j < this.SRN; j++) {\n        if (this.mat[rowStart + i][colStart + j] === num) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  // Fill a 3 x 3 matrix.\n  fillBox(row, col) {\n    let num = 0;\n    for (let i = 0; i < this.SRN; i++) {\n      for (let j = 0; j < this.SRN; j++) {\n        while (true) {\n          num = this.randomGenerator(this.N);\n          if (this.unUsedInBox(row, col, num)) {\n            break;\n          }\n        }\n        this.mat[row + i][col + j] = num;\n      }\n    }\n  }\n\n  // Random generator\n  randomGenerator(num) {\n    return Math.floor(Math.random() * num + 1);\n  }\n\n  // Check if safe to put in cell\n  checkIfSafe(i, j, num) {\n    return this.unUsedInRow(i, num) && this.unUsedInCol(j, num) && this.unUsedInBox(i - i % this.SRN, j - j % this.SRN, num);\n  }\n\n  // check in the row for existence\n  unUsedInRow(i, num) {\n    for (let j = 0; j < this.N; j++) {\n      if (this.mat[i][j] === num) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // check in the row for existence\n  unUsedInCol(j, num) {\n    for (let i = 0; i < this.N; i++) {\n      if (this.mat[i][j] === num) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // A recursive function to fill remaining\n  // matrix\n  fillRemaining(i, j) {\n    // Check if we have reached the end of the matrix\n    if (i === this.N - 1 && j === this.N) {\n      return true;\n    }\n\n    // Move to the next row if we have reached the end of the current row\n    if (j === this.N) {\n      i += 1;\n      j = 0;\n    }\n\n    // Skip cells that are already filled\n    if (this.mat[i][j] !== 0) {\n      return this.fillRemaining(i, j + 1);\n    }\n\n    // Try filling the current cell with a valid value\n    for (let num = 1; num <= this.N; num++) {\n      if (this.checkIfSafe(i, j, num)) {\n        this.mat[i][j] = num;\n        if (this.fillRemaining(i, j + 1)) {\n          return true;\n        }\n        this.mat[i][j] = 0;\n      }\n    }\n\n    // No valid value was found, so backtrack\n    return false;\n  }\n\n  // Print sudoku\n  printSudoku() {\n    for (let i = 0; i < this.N; i++) {\n      console.log(this.mat[i].join(\" \"));\n    }\n  }\n\n  // Remove the K no. of digits to\n  // complete game\n  removeKDigits() {\n    let count = this.K;\n    while (count !== 0) {\n      // extract coordinates i and j\n      let i = Math.floor(Math.random() * this.N);\n      let j = Math.floor(Math.random() * this.N);\n      if (this.mat[i][j] !== 0) {\n        count--;\n        this.mat[i][j] = 0;\n      }\n    }\n    return;\n  }\n}\n\n// Driver code\nlet N = 9;\nlet K = 40;\nlet sudoku = new Sudoku(N, K);\nsudoku.fillValues();\nsudoku.printSudoku();\n\n// This code is contributed by phasing17.","map":{"version":3,"names":["Sudoku","constructor","N","K","SRNd","Math","sqrt","SRN","floor","mat","Array","from","length","fillValues","DiagonalBoxes","fillRemaining","i","numbers","shuffleArray","keys","map","num","itemNumber","sudokuItem","pop","rowNumber","colNumber","boxNumber","board","push","box","row","col","unUsedInBox","rowStart","colStart","j","fillBox","randomGenerator","random","checkIfSafe","unUsedInRow","unUsedInCol","printSudoku","console","log","join","removeKDigits","count","sudoku"],"sources":["/Users/annikasingh/Desktop/hi/sudoku/src/components/Sudoku.js"],"sourcesContent":["// JS program to implement the approach\nexport class Sudoku {\n  // Constructor\n  constructor(N, K) {\n    this.N = N;\n    this.K = K;\n\n    // Compute square root of N\n    const SRNd = Math.sqrt(N);\n    this.SRN = Math.floor(SRNd);\n\n    // Initialize all entries as false to indicate\n    // that there are no edges initially\n    this.mat = Array.from({\n      length: N * N,\n    });\n  }\n\n  // Sudoku Generator\n  fillValues() {\n    // Fill the diagonal of SRN x SRN matrices\n    this.DiagonalBoxes();\n\n    // Fill remaining blocks\n    this.fillRemaining(0, this.SRN);\n\n    // Remove Randomly K digits to make game\n    //this.removeKDigits();\n  }\n\n  // Fill the diagonal SRN number of SRN x SRN matrices\n  // fillDiagonal() {\n  //   for (let i = 0; i < this.N; i += this.SRN) {\n  //     // for diagonal box, start coordinates->i==j\n  //     this.fillBox(i, i);\n  //   }\n  // }\n\n  DiagonalBoxes() {\n    for (let i = 0; i < 9; i += 4) {\n      let numbers = shuffleArray(\n        Array.from(Array(9).keys()).map((num) => num + 1)\n      );\n      for (let itemNumber = 0; itemNumber < 9; itemNumber++) {\n        let sudokuItem = numbers.pop() || 8;\n        let rowNumber = Math.floor(itemNumber / 3);\n        let colNumber = itemNumber % 3;\n        let boxNumber = i;\n        board.push({\n          box: boxNumber,\n          row: rowNumber,\n          num: sudokuItem,\n          col: colNumber,\n        });\n      }\n    }\n  }\n\n  // Returns false if given 3 x 3 block contains num.\n  unUsedInBox(rowStart, colStart, num) {\n    for (let i = 0; i < this.SRN; i++) {\n      for (let j = 0; j < this.SRN; j++) {\n        if (this.mat[rowStart + i][colStart + j] === num) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  // Fill a 3 x 3 matrix.\n  fillBox(row, col) {\n    let num = 0;\n    for (let i = 0; i < this.SRN; i++) {\n      for (let j = 0; j < this.SRN; j++) {\n        while (true) {\n          num = this.randomGenerator(this.N);\n          if (this.unUsedInBox(row, col, num)) {\n            break;\n          }\n        }\n        this.mat[row + i][col + j] = num;\n      }\n    }\n  }\n\n  // Random generator\n  randomGenerator(num) {\n    return Math.floor(Math.random() * num + 1);\n  }\n\n  // Check if safe to put in cell\n  checkIfSafe(i, j, num) {\n    return (\n      this.unUsedInRow(i, num) &&\n      this.unUsedInCol(j, num) &&\n      this.unUsedInBox(i - (i % this.SRN), j - (j % this.SRN), num)\n    );\n  }\n\n  // check in the row for existence\n  unUsedInRow(i, num) {\n    for (let j = 0; j < this.N; j++) {\n      if (this.mat[i][j] === num) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // check in the row for existence\n  unUsedInCol(j, num) {\n    for (let i = 0; i < this.N; i++) {\n      if (this.mat[i][j] === num) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // A recursive function to fill remaining\n  // matrix\n  fillRemaining(i, j) {\n    // Check if we have reached the end of the matrix\n    if (i === this.N - 1 && j === this.N) {\n      return true;\n    }\n\n    // Move to the next row if we have reached the end of the current row\n    if (j === this.N) {\n      i += 1;\n      j = 0;\n    }\n\n    // Skip cells that are already filled\n    if (this.mat[i][j] !== 0) {\n      return this.fillRemaining(i, j + 1);\n    }\n\n    // Try filling the current cell with a valid value\n    for (let num = 1; num <= this.N; num++) {\n      if (this.checkIfSafe(i, j, num)) {\n        this.mat[i][j] = num;\n        if (this.fillRemaining(i, j + 1)) {\n          return true;\n        }\n        this.mat[i][j] = 0;\n      }\n    }\n\n    // No valid value was found, so backtrack\n    return false;\n  }\n\n  // Print sudoku\n  printSudoku() {\n    for (let i = 0; i < this.N; i++) {\n      console.log(this.mat[i].join(\" \"));\n    }\n  }\n\n  // Remove the K no. of digits to\n  // complete game\n  removeKDigits() {\n    let count = this.K;\n\n    while (count !== 0) {\n      // extract coordinates i and j\n      let i = Math.floor(Math.random() * this.N);\n      let j = Math.floor(Math.random() * this.N);\n      if (this.mat[i][j] !== 0) {\n        count--;\n        this.mat[i][j] = 0;\n      }\n    }\n\n    return;\n  }\n}\n\n// Driver code\nlet N = 9;\nlet K = 40;\nlet sudoku = new Sudoku(N, K);\nsudoku.fillValues();\nsudoku.printSudoku();\n\n// This code is contributed by phasing17.\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}